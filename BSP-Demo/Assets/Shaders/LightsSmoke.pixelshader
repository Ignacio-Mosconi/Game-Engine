#version 330 core

in vec2 _UV;
in vec4 _LightColors[10];
in float _Intensities[10];
in float _Radiuses[10];
in float _AngularSpeeds[10];
in int _NumberOfLights;
in vec2 _Center;

out vec4 color;

uniform sampler2D _BackgroundTexture;

vec3 mod289(vec3 x)
{
    return (x - floor(x * (1.0 / 289.0)) * 289.0);
}

vec4 mod289(vec4 x) 
{
    return (x - floor(x * (1.0 / 289.0)) * 289.0);
}

vec4 mod(vec4 x, float y)
{
    return (x - floor(x * (1.0 / y)) * y);
}

vec4 permute(vec4 x) 
{
    return (mod289(((x * 34.0) + 1.0) * x));
}

vec4 taylorInvSqrt(vec4 r)
{
    return (1.79284291400159 - 0.85373472095314 * r);
}

vec snoise(vec3 v)
{ 
    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

    // First corner
    vec3 fragmentData = floor(v + dot(v, C.yyy));
    vec3 x0 = v - fragmentData + dot(fragmentData, C.xxx);

    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);

    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

    // Permutations
    fragmentData = mod289(fragmentData); 
    vec4 p = permute(permute(permute( 
                fragmentData.z + vec4(0.0, i1.z, i2.z, 1.0))
                + fragmentData.y + vec4(0.0, i1.y, i2.y, 1.0)) 
                + fragmentData.x + vec4(0.0, i1.x, i2.x, 1.0));

    // Gradients: 7x7 points over a square, mapped onto an octahedron.
    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
    float n_ = 0.142857142857; // 1.0/7.0
    float3 ns = n_ * D.wyz - D.xzx;

    vec4 j = mod(p , 49.0);

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = mod(j, 7.0);

    vec4 x = x_ * ns.x + ns.yyyy;
    vec4 y = y_ * ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);

    vec4 s0 = floor(b0) * 2.0 + 1.0;
    vec4 s1 = floor(b1) * 2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0, 0.0, 0.0, 0.0));

    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);

    //Normalise gradients
    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
    m = m * m;
            
    return (42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))));
}

float normnoise(float noise) 
{
    return (0.5 * (noise + 1.0));
}

float clouds(vec2 _UV) 
{
    _UV += vec2(iTime * 0.05, iTime * 0.01);
            
    vec2 offset1 = vec2(3.0, 2.0);
    vec2 offset2 = vec2(0.0, 0.0);
    vec2 offset3 = vec2(-10, 5.0);
    vec2 offset4 = vec2(-10, 20.0);
    vec2 offset5 = vec2(40.0, -20.0);
    vec2 offset6 = vec2(12.0, -100.0);
    float scale1 = 2.0;
    float scale2 = 4.0;
    float scale3 = 8.0;
    float scale4 = 16.0;
    float scale5 = 32.0;
    float scale6 = 64.0;
            
    return normnoise(snoise(vec3((_UV + offset1) * scale1, iTime * 0.5)) * 0.8 + 
                    snoise(vec3((_UV + offset2) * scale2, iTime * 0.4)) * 0.4 +
                    snoise(vec3((_UV + offset3) * scale3, iTime * 0.1)) * 0.2 +
                    snoise(vec3((_UV + offset4) * scale4, iTime * 0.7)) * 0.1 +
                    snoise(vec3((_UV + offset5) * scale5, iTime * 0.2)) * 0.05 +
                    snoise(vec3((_UV + offset6) * scale6, iTime * 0.3)) * 0.025);
}

void main()
{
	vec4 textureColor = texture(_BackgroundTexture, _UV);
    vec3 lightsColor;

    for (int i = 0; i < _NumberOfLights; i++)
    {
        vec2 light = vec2(cos(iTime * _AngularSpeeds[i]) * _Radiuses[i], 
								sin(iTime * _AngularSpeeds[i]) * _Radiuses[i]) + 
								_Center;
        float dist = distance(_UV, light);
        float cloudIntensity = _Intensities[i] * (1.0 - 2.5 * dist);
        float lightIntensity = _Intensities[i] / (100.0 * dist);
        float finalCloud = vec3(cloudIntensity * clouds(_UV), cloudIntensity * clouds(_UV), cloudIntensity * clouds(_UV));
                
        lightsColor += (lightIntensity + finalCloud) * _LightColors[i];
    }

    color = lightsColor + textureColor;
}